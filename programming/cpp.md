# C++ 编程风格指南

## 目录

## 头文件

### 多重包含

使用 `#define` 进行保护，宏命名参考 `PROJECT_PATH_FILE_H_`

例如文件：foo/src/bar/baz.h

```cpp
#ifdef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_

// 声明部分

#endif // FOO_BAR_BAZ_H_
```

> 笔者推荐命名方式为 `_PROJECT_MODLUE_FILE_H_`，注释方式也略有不同

```cpp
#ifdef _FOO_BAR_BAZ_H_
#define _FOO_BAR_BAZ_H_

// 声明部分

#endif /* _FOO_BAR_BAZ_H_ */
```

### 头文件依赖

前置声明：降低编译依赖，防止修改导致多米诺效应，能依赖声明的就不要依赖定义。

+ 参数、返回值类型使用 `Foo` 的方法只声明不定义实现
+ 将成员变量声明成 `Foo*` 或 `Foo&` 类型，静态成员在类定义之外，不需要这样做
+ 不降低代码可读性和效率有选择性使用指针成员代替对象成员

举个栗子：

```cpp
class Foo;

class Bar {
 private:
    Foo* foo_;
};
```

### 内联函数

合理使用可提高代码执行效率，比如函数只有 10 行甚至更少的时候。

### *-inl.h

将复杂的内联函数的定义放在这个文件中，提高代码可读性。

### 函数参数顺序

输入参数在前，输出参数在后

> 对函数参数的堆栈空间有轻微影响，笔者习惯按函数内部使用顺序排序

### 包含文件的名称及次序

+ 使用完整的项目路径，看上去会很清晰，很条理
+ 次序：源文件的头文件，C 系统头文件，C++ 系统头文件，其他库头文件，内部头文件

减少隐藏依赖，使每个头文件在 “最需要编译” 的地方编译

## 作用域

### 命名空间

+ 推荐使用匿名命名空间来避免命名冲突，虽然违背了唯一定义原则
+ 不要声明命名空间 `std` 下的任何内容
+ 避免使用 `using`，确保命名空间下所有名称都可用
+ 适当使用命名空间别名简化定义 `namespace fbz = ::foo::bar::baz;`

留有适当的注释

```cpp
namespace foo {
enum {UNUSED, EOF, ERROR };
bool AtEof() { return pos_ == EOF; }
} // namespace foo
```

> 笔者的注释略有不同

```cpp
namespace bar {
class MyClass {
};
} /* namespace: bar */
```

### 嵌套类

+ 推荐使用命名空间代替嵌套类
+ 尽量不要定义成 `public`，除非接口需要

### 函数

+ 有时不把函数限定在类实体中是有益的
+ 单纯封装若干不共享任何静态数据的静态成员函数而创建的类，不如使用命名空间
+ 全局函数不如使命命名空间的非成员函数或静态成员函数
+ 独立的命名空间或新类可以解决跨编译单元调用的函数所引入的耦合和依赖

### 局部变量

+ 尽可能的使用最小作用域，距离使用越近越好，最好初始化跟赋值在一起
+ 如果变量是在循环体中的对象，频繁的构造和析构是低效的，应放到循环外面声明

### 全局变量

+ 禁止类(含 STL)、多线程、函数返回初始化全局变量
+ 内建类型和只有内建类型构成的结构体可以使用
+ 单例类可考虑使用类的全局变量
+ 字符串常量只能使用 `const char []`

### 小结

规范作用域除了考虑名称污染、可读性之外，主要是为降低耦合，提高编译/执行效率。

## 类

### 构造函数

+ 只进行没有实际意义的操作，不要做太多逻辑相关的初始化
+ 可能的话，有意义的初始化交给 `init()` 方法
+ 不要调用虚函数，调用了也不会派发给子类
+ 类对象不要充当全局变量，在主函数之前初始化会破坏函数暗含假设条件和标志位
+ 默认生成的构造函数不会对成员变量进行初始化
+ 为单参数构造函数添加 `explicit` 声明，可避免产生一个新对象和隐式转换
+ 拷贝构造函数和作为委托的透明包装器类可忽视 `explicit` 转换
+ 不需要拷贝类对象的时候最好限制拷贝构造函数，避免性能问题和调试困难
+ 使用 `std::tr1::shared_ptr` 作为使用指针指向 STL 容器中的对象，尽量不拷贝类

```cpp
#define DISALLOW_COPY_AND_ASSIGN(TypeName)  \
    TypeName(const TypeName&);              \
    void operator=(const TypeName&)

class Foo {
 public:
    Foo();
    ~Foo();

 private:
    DISALLOW_COPY_AND_ASSIGN(Foo);
};
```

### 结构体与类

只有作为数据集合时使用 `struct`，其他都用 `class`

### 继承

+ 能用组合就不用继承，明确两者关系为 “是一个” 的时候再继承
+ 必要的话，析构函数修饰为 `virtual`，即便没有任何数据成员，编程规范上也需定义
+ 重写派生类虚函数时，应保留 `virtual`，便于快速了解 “家庭背景”
+ 避免多重继承，必要时除一个基类含实现外其他基类为纯接口，以 `Interface` 结尾

### 接口

+ 无非静态成员
+ 无任何形式的构造函数，默认构造只能是 `protected`
+ 只有纯虚函数和静态函数，析构函数可选
+ 子类也必须满足以上条件
+ 可选用 `Interface` 结尾

### 重载操作符

+ 尽量不重载操作符，降低复杂性，尤其是赋值操作
+ 如果需要类似操作，定义对应方法代替
+ 不应仅仅为 STL 容器的键值重载 `==` 或 `<`

### 存取控制

成员私有化，提供对应存取函数，然后丢到内联头文件里面去

### 声明次序

+ `public` 早于 `protected`，早于 `private`
+ `typedef` 和 `enum`
+ 常量
+ 构造函数
+ 析构函数
+ 成员函数 (含静态成员函数)
+ 成员变量 (含静态成员变量)
+ `DISALLOW_COPY_AND_ASSIGN` 单独跟 `private:` 放在最后

> 实现文件的函数定义尽可能与声明次序一致

### 编写短小的函数

函数体尽量短小，紧凑，功能单一

## 特性

### 智能指针

+ 优先使用 `scoped_ptr`，安全第一
+ 特殊情况使用 `std::tr1::shared_ptr`
+ 任何情况都不要用 `auto_ptr`
+ 设计对象隶属明确的代码，最明确的对象隶属是不适用指针

### 引用参数

+ 必须使用 `const` 修饰，强调不是拷贝出来的
+ 在对象生命周期内一直存在或特定接口时可用常数指针代替

### 函数重载

+ 输入参数类型不同，功能相同时再重载
+ 不要模仿使用默认函数参数
+ 尽可能让函数名包含参数信息

### 友元

+ 定义在同一文件目录内，以 `Builder` 结尾
+ 常用于做类的单元测试
+ 不打破类封装的边界，也减少了不必要的 `public` 成员

### 类型转换

+ 不再使用 C 的强制类型转换
+ 除测试外，不使用 `dynamic_cast`

### 流

+ 日志接口中可选择使用
+ 不要在代码中使用流，保持一致性

### 前置自增减

因为后置会多做一次拷贝，所以迭代器和模板对象应使用前置

### const

任何可以使用的情况下都使用 `const`，推荐添加在描述名词前面

### 整数

+ 使用 `<stdint.h>` 指定精确宽度的整数
+ 无符号类型只在表示位组时使用
+ 如果数值非负，使用 `assert` 判断
+ C 整数中只使用 `int`，适当使用 `size_t` 和 `ptrdiff_t`

### 64 位可移植性

+ `sizeof(void*)` 不再等于 `sizeof(int)`，整数指针的大小要用 `intptr_t`
+ 64 位上拥有 `[u]int64` 的类或结构体都是 8 字节对齐
+ 创建 64 位常量时使用 `LL` 或 `ULL` 作为后缀
+ 尽量不要让 32 位和 64 位系统的代码不同
+ C99 定义了 `printf` 的可移植版本，但 MSVC 7.1 并不完善，还需要自定义： 

```cpp
// printf macros for size_t
#ifdef _LP64
#define __PRIS_PREFIX "z"
#else
#define __PRIS_PREFIX
#endif

// macros after %
#define PRIds __PRIS_PREFIX "d"
#define PRIxs __PRIS_PREFIX "x"
#define PRIus __PRIS_PREFIX "u"
#define PRIXs __PRIS_PREFIX "X"
#define PRIos __PRIS_PREFIX "o"
```

前后对照

| 类型      | 不要使用          | 使用      | 备注      |
|:---------:|:-----------------:|:---------:|:---------:|
| void*     | %lx               | %p        |           |
| int64_t   | %qd, %lld         | %"PRId64" |           |
| uint64_t  | %qu, %llu, %llx   | %"PRIu64" |           |
| size_t    | %u                | %"PRIuS"  | C99: %zu  |
| ptrdiff_t | %d                | %"PRIdS"  | C99: %zd  |

### 预处理宏

+ 尽量用内联、枚举和常量代替
+ 最好不用条件编译
+ 不要在头文件中定义宏
+ 正确的使用 `#define` 和 `#undef`
+ 尽量选择一个不会冲突的宏名

### sizeof

尽可能用 `sizeof(varname)` 代替 `sizeof(type)`，解决变更类型的同步问题

### 禁止使用列表

+ 默认函数参数
+ 变长数组
+ `alloca()`，用安全的分配器代替，比如 `scoped_ptr`/`scoped_array`
+ 异常
+ 运行时类型识别

## 命名

### 通用规则

+ 名称具有描述性，不要过度缩写
+ 类型和变量应该是名词，函数名是 “命令性” 的动词
+ 除非放到项目外也非常明确，否则不要缩写

### 文件

+ 全部小写
+ 使用下划线或短线连接
+ 头文件后缀名为 `.h`，实现文件后缀名为 `.cc`
+ 不要使用系统目录下已存在的文件名
+ 头文件、内联头文件以及实现尽可能在同一目录

### 类型

+ 每个单词大写首字母
+ 不要使用下划线
+ 类型包括：类、结构体、类型定义、枚举

### 变量

+ 全部小写
+ 下划线链接，类成员变量下划线结尾
+ 最好别用全局变量，用的话增加 `g_` 前缀

### 常量

+ 使用 `k` 作为前缀
+ 后面每个单词大写首字母

### 函数命名

+ 存取函数与变量名匹配
+ 短小的内联函数小写字母
+ 普通函数大小写混合，首字母大写，没有下划线

> 小写的函数名意味着可以直接内联使用

### 命名空间

+ 全小写
+ 下划线连接

### 枚举

+ 全大写
+ 下划线连接

### 宏

+ 尽量不用
+ 全大写，下划线连接

### 例外

当命名与现有实体类似时，参考现有命名约定

## 注释

最好的代码本身就是文档

### 风格

使用 `//` 还是 `/* */` 都行，重要的是一致性

### 文件

+ 版权公告顺序：版权、许可证、作者、贡献者
+ 内容：类功能、用法简要说明，实现细节或讨论算法
+ 不要单纯在文件间复制注释，这偏离了实际意义

### 类

+ 定义处说明功能和用法
+ 说明任何同步前提

### 函数

+ 声明处描述输入输出、是否需要释放、可否为空、性能、同步前提
+ 没有意义的注释是没有必要的
+ 定义处说明实现要点，不要复制声明处的注释

### 变量

+ 变量名称本身应足以说明用途
+ 特定情况才需要注释说明：类成员变量的警戒值，全局变量存在的意义

### 实现

+ 针对巧妙、晦涩、有趣、重要的地方
+ 向函数传入布尔或整数数值时，或使用描述性变量
+ 不要用自然语言翻译代码充当注释

### 标点、拼写和语法

+ 适当的大写和句号表示完整的句子
+ 风格一致性
+ 清晰易读很重要

### TODO

+ 针对临时的、短期的解决方案
+ 已经够好但不完美的代码
+ 后面加上你的大名跟邮箱

### 小结

+ 文件注释可以炫耀你的成就，也是为了捅了篓子别人可以找你
+ 言简意赅，不要拖沓冗余，复杂的东西简单化和简单的东西复杂化都是要被鄙视的
+ 注释不要太乱，适当的缩进才会让人乐意看。

## 格式

### 行长度

不要超过 80 个字符，除非是特别长的命令、路径或 URL

### 非 ASCII 字符

尽量不要用，必要时用 UTF-8

### 空格还是制表位

只用空格，每次缩进两个

> 笔者注：推荐还是 4 个空格代替制表位缩进

### 函数声明与定义

+ 返回值类型跟函数名在同一行
+ 左圆括号跟函数同一行，中间没有空格
+ 尽量把参数也放到函数名那一行
+ 多行形参尽量对齐
+ 左大括号跟最后一个参数同一行，与右圆括号空一格
+ 右大括号总是单独一行

### 函数调用

+ 尽量在同一行，多行保持实参对齐
+ 如果函数名过长，所有实参独立成行

### 流程控制语句

+ 圆括号内不要有空格，`if` 跟圆括号，圆括号跟大括号之间都有一个空格
+ 关键字 `else` 另起一行
+ 尽可能都使用大括号，如果可以更好的表达语义，请保持分支一致性
+ `switch` 总是有个 `default`，分支可选使用大括号分块
+ 空循环也需要使用大括号，不是简单的一个分号

### 指针和引用表达式

+ `.`、`->`、`*`、`&` 后面不要有空格
+ 同一个文件内保持一致性

### 布尔表达式

+ 注意行宽 80
+ 逻辑运算符作为尾行
+ 添加合理的圆括号增加可读性

### 函数返回值

+ 不要使用圆括号

### 预处理指令

+ 不要缩进，即使处于缩进代码块

### 类

+ 声明属性每次缩进一个空格，后面不要空行
+ `public` 在最前面

### 初始化列表

+ 同一行
+ 或对齐缩进

### 命名空间

+ 内容不缩进

### 留白

+ 因地制宜的水平留白，不要在行尾添加无谓的东西
+ 垂直留白越少越好，尤其在定义间不要超过两行，头尾也不要有空行
+ if-else 之间空一行是可以接受的

### 小结

+ 用代码把 12 寸的显示屏都占满，怎么也说不过去，行宽就 80 字符了
+ 尽量不将字符串常量耦合到代码中，比如独立出资源文件，这不仅仅是风格问题了
+ 预处理指令/命名空间不使用额外缩进，类/结构体/枚举/函数/语句使用缩进
+ 初始化用 `=` 还是 `()` 依个人喜好, 统一就好

## 规则之外

### 现有不统一的代码

尽量保持与原风格一致

### Window

+ 不要用匈牙利命名法，使用 `.cc` 扩展名
+ 尽量用 C++ 原有的类型，而不是 Windows 内建类型
+ 编译时警告级别设置成 3 或更高，所有警告当错误处理
+ 不要使用 `#pragma once;` 作为包含保护
+ 尽量不适用不标准的扩展，比如 `#pragma` 和 `__declspec`，必要时用宏提高移植性
+ 多重继承和异常处理请视而不见
+ 避免显式包含 `StdAfx.h` 或 `precompile.h` 此类文件



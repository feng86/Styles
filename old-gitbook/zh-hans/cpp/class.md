#### 类

##### 构造函数

+ 只进行没有实际意义的操作，不要做太多逻辑相关的初始化
+ 可能的话，有意义的初始化交给 `init()` 方法
+ 不要调用虚函数，调用了也不会派发给子类
+ 类对象不要充当全局变量，在主函数之前初始化会破坏函数暗含假设条件和标志位
+ 默认生成的构造函数不会对成员变量进行初始化
+ 为单参数构造函数添加 `explicit` 声明，可避免产生一个新对象和隐式转换
+ 拷贝构造函数和作为委托的透明包装器类可忽视 `explicit` 转换
+ 不需要拷贝类对象的时候最好限制拷贝构造函数，避免性能问题和调试困难
+ 使用 `std::tr1::shared_ptr` 作为使用指针指向 STL 容器中的对象，尽量不拷贝类

```cpp
#define DISALLOW_COPY_AND_ASSIGN(TypeName)  \
    TypeName(const TypeName&);              \
    void operator=(const TypeName&)

class Foo {
 public:
    Foo();
    ~Foo();

 private:
    DISALLOW_COPY_AND_ASSIGN(Foo);
};
```

##### 结构体与类

只有作为数据集合时使用 `struct`，其他都用 `class`

##### 继承

+ 能用组合就不用继承，明确两者关系为 “是一个” 的时候再继承
+ 必要的话，析构函数修饰为 `virtual`，即便没有任何数据成员，编程规范上也需定义
+ 重写派生类虚函数时，应保留 `virtual`，便于快速了解 “家庭背景”
+ 避免多重继承，必要时除一个基类含实现外其他基类为纯接口，以 `Interface` 结尾

##### 接口

+ 无非静态成员
+ 无任何形式的构造函数，默认构造只能是 `protected`
+ 只有纯虚函数和静态函数，析构函数可选
+ 子类也必须满足以上条件
+ 可选用 `Interface` 结尾

##### 重载操作符

+ 尽量不重载操作符，降低复杂性，尤其是赋值操作
+ 如果需要类似操作，定义对应方法代替
+ 不应仅仅为 STL 容器的键值重载 `==` 或 `<`

##### 存取控制

成员私有化，提供对应存取函数，然后丢到内联头文件里面去

##### 声明次序

+ `public` 早于 `protected`，早于 `private`
+ `typedef` 和 `enum`
+ 常量
+ 构造函数
+ 析构函数
+ 成员函数 (含静态成员函数)
+ 成员变量 (含静态成员变量)
+ `DISALLOW_COPY_AND_ASSIGN` 单独跟 `private:` 放在最后

> 实现文件的函数定义尽可能与声明次序一致

##### 编写短小的函数

函数体尽量短小，紧凑，功能单一

